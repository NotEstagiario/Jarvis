generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

enum Language {
  PT_BR
  EN
}

enum MatchStatus {
  PENDING
  ACTIVE
  FINISHED
  CANCELED
  DISPUTED
}

enum ResultStatus {
  DRAFT
  WAITING_OPPONENT
  STAFF_REVIEW
  CONFIRMED
  CANCELED
}

enum ConfidenceFlagType {
  TIMEOUT_STAFF_REVIEW
  DISPUTED
  WO_REQUESTED
  OCR_FAIL
  FARM_SUSPECT
  REPEAT_MATCH_LIMIT
  STAFF_EDITED_SCORE
}

enum BindingStatus {
  PENDING
  APPROVED
  DENIED
}

model Player {
  id                String   @id @default(cuid())
  guildId           String
  discordId         String

  language          Language @default(PT_BR)

  // Competitive stats (persistent)
  matches           Int      @default(0)
  wins              Int      @default(0)
  losses            Int      @default(0)
  draws             Int      @default(0)
  goalsFor          Int      @default(0)
  goalsAgainst      Int      @default(0)

  currentWinStreak  Int      @default(0)
  bestWinStreak     Int      @default(0)

  championships     Int      @default(0)

  xp                Int      @default(0)

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@unique([guildId, discordId])
  @@index([guildId])
}

model Match {
  id            String      @id @default(cuid())
  guildId       String
  status        MatchStatus @default(PENDING)

  authorId      String
  opponentId    String

  acceptedAt    DateTime?
  finishedAt    DateTime?

  token         String?     @unique

  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  @@index([guildId, status])
  @@index([guildId, authorId])
  @@index([guildId, opponentId])
}

model Result {
  id                 String       @id @default(cuid())
  guildId            String
  matchId            String
  status             ResultStatus  @default(DRAFT)

  authorId           String
  opponentId         String

  homeScore          Int?
  awayScore          Int?

  authorConfirmedAt  DateTime?
  opponentConfirmedAt DateTime?

  printUrl            String?
  printMessageId      String?
  printChannelId      String?

  createdAt          DateTime     @default(now())
  updatedAt          DateTime     @updatedAt

  @@index([guildId, matchId])
  wizardMessageId String?
  wizardChannelId String?
}


model ConfidenceFlag {
  id         String             @id @default(cuid())
  guildId    String
  type       ConfidenceFlagType
  playerId   String?
  matchId    String?
  resultId   String?
  metaJson   String?

  createdAt  DateTime           @default(now())

  @@index([guildId, type])
}

model CommandChannelBinding {
  id                String        @id @default(cuid())
  guildId           String
  commandKey        String
  channelId         String
  status            BindingStatus @default(PENDING)

  requestedByUserId String
  approvedByUserId  String?
  approvedAt        DateTime?

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@unique([guildId, commandKey])
  @@index([guildId, status])
}

model CommandCooldown {
  id         String   @id @default(cuid())
  guildId    String
  userId     String
  commandKey String
  lastUsedAt DateTime @default(now())

  @@unique([guildId, userId, commandKey])
  @@index([guildId, commandKey])
}


model PairCooldown {
  id            String   @id @default(cuid())
  guildId       String
  playerAId     String
  playerBId     String

  lastFinishedAt DateTime?
  cooldownUntil  DateTime?

  // how many rematches used to bypass cooldown after lastFinishedAt
  rematchesUsed  Int @default(0)

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([guildId, playerAId, playerBId])
  @@index([guildId])
}

model RematchOffer {
  id            String   @id @default(cuid())
  guildId       String
  matchId       String
  winnerId      String
  loserId       String
  expiresAt     DateTime
  usedAt        DateTime?

  createdAt     DateTime @default(now())

  @@index([guildId, loserId])
  @@index([guildId, winnerId])
}


model FixedMessage {
  id        String   @id @default(cuid())
  guildId   String
  key       String
  channelId String
  messageId String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([guildId, key])
  @@index([guildId])
}



model MatchCancelRequest {
  id          String   @id @default(cuid())
  guildId     String
  matchId     String
  token       String

  authorId    String
  opponentId  String

  authorReason   String
  opponentReason String?

  status      String   @default("PENDING") // PENDING, ACCEPTED, DENIED, STAFF_REVIEW

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([guildId])
  @@index([guildId, token])
}


model RankingState {
  guildId       String  @id
  rankingDirty  Boolean @default(false)
  lastUpdatedAt DateTime @default(now())
}


model WoRequest {
  id         String   @id @default(cuid())
  guildId    String
  matchId    String
  token      String?
  authorId   String
  opponentId String
  printUrl   String
  reason     String?
  status     String   @default("AUTHOR_PENDING") // AUTHOR_PENDING | STAFF_REVIEW | APPROVED | DENIED
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}


model RematchCredit {
  id        String   @id @default(cuid())
  guildId   String
  playerA   String
  playerB   String
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime @default(now())

  @@index([guildId, playerA, playerB])
}


model MatchmakingInvite {
  id        String   @id @default(cuid())
  guildId   String
  channelId String
  messageId String?

  authorId  String
  filter    String   @default("ANY") // ANY/SAME/ABOVE_1/ABOVE_2P/BELOW_1/BELOW_2P

  status    String   @default("ACTIVE") // ACTIVE/ACCEPTED/CANCELED/EXPIRED
  expiresAt DateTime

  acceptedById String?
  acceptedAt   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([guildId, authorId, status])
}
